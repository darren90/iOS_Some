#前言

目前正在离职中（裸辞），准备离开北京了，自然也需要做一些求职的准备。大深圳等我太久了，决定回深圳先玩半个月，再好好找工作。

今天看到了bestswifter的一篇BAT面试指南，决定试答一下。算起来我的面试经历并不丰富，倒是当过面试官面过不少同学，将下来换成我当求职者了，心态需要做一下下转变。如果本篇文章中的答案，与您的想法有出入，不如提出来一起聊聊！

**郑重声明内容来源：**所有题目来源于[BAT 面试指南](http://www.tuicool.com/articles/quuUJvM#0-tsina-1-4272-397232819ff9a47a7b7e80a40613cfe1)


#一面四个算法题：

不管怎么说，当年大学毕业的时候，百度一面通过了，二面的时候被算法题给刷了。记得当年我面试的是深圳C++算法工程师，一面的算法题我答得挺好的，但是到二面的时候，是一个年轻的小伙子面试的我，刚开始问的链表的常用操作、栈等相关的算法还是答得可以的，可是到后面让我手写堆排序，只好老实说不会（大学只讲了数据结构书中堆排序的皮毛，10分钟就带过了），后来又问什么操作系统内存碎片是如何处理的，采用什么样的算法。。。至今还不懂！

言归正传，这次若是有机会再去百度面试，我不会再像刚毕业那时紧张了。下面的四道算法题，尝试做一做！

##1.1、不用临时变量怎么实现swap(a, b)

解决的办法可能有很多种，不过这里提供两种方式来实现。

###1.1.1 位运算实现交换

通过位运算实现交换，首先将a = a ^^ b，再执行第二条b = a ^^ b就可以得到b = a，但是此时a还不是了，再执行a = a ^^ b，那么a就变成b了（这种方式是我最熟悉的）：

```
NSInteger a = 19;
NSInteger b = 99;
  
a = a ^ b;
b = a ^ b;
a = a ^ b;

// a = 99, b = 19
NSLog(@"a = %ld, b = %ld", a, b);
```

###1.1.2 算术运算实现交换

实现原理：将a、b看作数轴上的两个点，利用差值来计算两者的距离并保存到其中一个变量中，再利用这个距离与a、b的差值或者和计算出交换后的a、b值：

```
NSInteger a = -1;
NSInteger b = 1;
  
a = a + b;
b = a - b;
a = a - b;
  
NSLog(@"a = %ld, b = %ld", a, b);
```

这种方式也不需要借助临时变量，但是这种方式有很大的局限性，比如
a、b本是不溢出的，但是a+b后可能会溢出。


##1.2、二维有序数组查找数字

题目明确告诉我们：数组是二维的，而且是有序的，目标是查找数字。题目没有明确说明如何查找，我想可能是希望求职者以尽可能高效的算法来查找数字。

其实我个人看到题目第一反映就是折半查找算法了，但是好像遇到使用折半查找算法的都是一维有序数组吧？假设下面是二维数组：

```
[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
```

这其实是一个三行四列的矩阵，如何才能高效地查找某个值的位置呢？如果我们采用最常规的双重遍历，那出这道题就没有意义了。

下面，我们一起来分析一下，如何查找才快一些呢。当然我的想法不是最高效的，只是比双重遍历要快一些而已，但是我相信对于面试官而言，这已经足够了。面试官决不是必须要你实现出最高效的算法，只是希望求职者能够认真地分析并以自己的想法描述出一种比常规算法要高效一点点的就可以了。

假设，我们查找数字34，那么我们可以这么找：

1. 先查找第一行最后一个元素，若等于34，则查找成功；若>34，则必定就是这一行或者不存在；若<34，则说明必定是后面的行中或者根本不存在。
2. 若第一步最后一个元素>34，则可以采用折半查找这一行。
3. 若第一步最后一个元素<34，则说明不在第一行，则继续查找下一行最后一个元素，直到找到>34为止或者直接查找结束。
4. 当查找到最后一个元素>34的行时，折半查找这一行即可。

时间复杂度分析：我们查找第一行最后一个元素，最坏情况下是column次，而折半查找是log2^^n
，那么最终时间复杂度为：column * log2^^n

下面是我写的一部分代码，没有写成函数，只是直接写来测试一下我的算法：

```
const int rows = 3;
const int cols = 4;
int array[rows][cols] = {{1, 3, 5, 7}, {10, 11, 16, 20}, {23, 30, 34, 50}};
int searchNum = 34;
// 是否查找成功
int found = 0;

// 查找第一行最后一个元素
for (int i = 0; i < rows; ++i) {
  int last = array[i][cols - 1];
  
  if (last == searchNum) {
    NSLog(@"找到了，位置为：(%d, %d)", i, cols - 1);
    break;
  }
  // 说明待查找的元素就在这一行，或者根本不存在
  else if (last > searchNum) {
    int mid = 0;
    int low = 0;
    int high = cols - 1;
    
    while (low <= high) {
      mid = (low + high) / 2;
      
      if (array[i][mid] == searchNum) {
        found = YES;
        NSLog(@"找到了，位置为：(%d, %d)", i, cols - 1);
        return;
      } else if (array[i][mid] > searchNum) {
        high = mid - 1;
      } else {
        low = mid + 1;
      }
    }
    
    if (!found) {
      NSLog(@"查找失败了，元素并不在二维数组中");
    }
  }
}
```

我相信还有更高效的算法，不过在面试时能想到这种方式，我觉得还算可以的了。如果我们查找最后一个元素，修改成采用折半查找每行最后一个元素，那么效率是不是又提高了？相当于做两次折半查找，便可查找成功或者不存在。

##1.3、亿级日志中，查找登陆次数最多的十个用户

假设只有一亿级日志，每条日志占用255字节，那么1亿就有1.0/4K *10000 * 10000 == 2500 * 10000M=>2.44 * 10000M == 24400M ~= 23.8G，可想而知是不能同时放入内存中的。

1. 我们可以通过分割成很多份，通过hash(key)对1024取模，分成1024个份，每份占用约23.8M，完全可以放内存中。
2. 然后分别对每一份操作，以登录次数作为hash的key，若key存在，则只是使key加1，若不存在则key值设置为1，只保留key值最大的10条记录，其余都丢掉（释放内存）
3. 当执行完毕后，内存中共有10 * 1024条记录，共10 * 0.25K * 1024 = 2.5M，因此内存使用上没有问题
4. 对这10 * 1024条记录排序，采用最小堆排序，或者采用红黑树（平衡二叉树）排序，提取前值最大的10条。

以上纯属个人想法，每条日志大小255字节也是假设值。

##1.4、简述排序算法

* [快速排序](http://101.200.209.244/quick-sort/)：利用分而治之的思想，每一趟比较中保证左边的比基准数小，右边的都比基准数大。每一趟排序时，需要划分出基准数，通过partition函数来划分，得到基准后，再递归排序基准数左边的部分，递归排序基准数右边的部分。

* [堆排序](http://101.200.209.244/heap-sort/)：堆分为最大堆和最小堆。最大堆是每次调整堆后，保证堆顶元素是最大元素，然后将当前未有序的元素中的最后一个元素与之交换，保证右边不断有序，而左边无序元素越来越少，因此最大堆排序后是升序序列；最小堆是每次调整堆后，保证堆顶元素是最小元素，然后将当前未有序的元素中的最后一个元素与之交换，保证右边不断有序，而左边无序元素越来越少，因此最小堆排序后得到的是降序序列。

* [归并排序](http://101.200.209.244/mergesort/)：采用分治法，通过将序列中分成子序列，递归归并成有序的若干个子序列，然后再二路归并成各个更大的子序列，最后再二路归并成最终序列。

* [冒泡排序](http://101.200.209.244/bubble-sort/)：所谓冒泡，就像水中冒泡一样，将值小的不断将上浮，值大的不断往下沉。每一趟都将值最大的交换到这一趟的最后，保证待查找序列部分最后一个元素是最大值。

* [插入排序](http://101.200.209.244/insert-sort/) 插入排序分为直接插入排序和折半插入排序。对于直接插入排序，每一趟都寻找a[i-1] > a[i]的，说明这时候是无序的，记录待排序值a[i]，然后将前面已有序的部分，移动位置，使a[i]值插入后，已有序部分依然有序；对于折半插入排序，每一趟都通过折半查找的方式来查找元素，然后移动位置，将之插入，使之有序，不过折半插入排序需要一个哨兵位置a[0]。

#小结

本篇文章只是bestswifter文中的一面部分内部，**下一篇**继续整理其所提到的**二面**内容。通过一面，看起来一面的算法题并不算复杂，但愿待我有机会面试的时候也是差不多难度的！

**声明：**所有题目答案纯属个人想法，没有正确性保证，仅供参考。若有疑问，请指出！

