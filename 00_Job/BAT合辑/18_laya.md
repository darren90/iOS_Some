### 1. cateogory 和 继承的区别 以及category 是干啥用的 是什么

cateogory是OC特有的属性，可以在不改变类名和原类的实现的前提下，进行类的扩展


以下几种情况，最好使用分类：

a. 针对系统的一些类进行扩展。例如，NSString, NSArray, NSNumber等类，系统本身不提倡使用继承去扩展方法，因为这些类内部实现对继承有所限制，所以最好用分类的方式扩展。

b.类别支持开发人员针对自己构建的类，把相关的方法分组到多个单独的文件中，针对大型而复杂的类，可以提高维护性和可读性，并简化单个源文件的管理。

## KVC /KVO的底层原理和使用场景

参考[KVC /KVO的底层原理和使用场景](http://www.jianshu.com/p/2ea8bd7a372b)

KVC:

1. 动态的取值和设值
2. 用KVC来访问和修改私有变量
3. Model和字典转换
4. 修改一些控件的内部属性

KVO：

1. 能够监听某个对象属性值的改变

### iOS 系统SDK 中使用到的设计模式

代理

观察者


###  delegate和Notification的区别

一对一 一对多

### 7. BLOCK 是什么 怎么用 和DELEGATE 的区别

带有自动变量的匿名函数

代理的方法比较多，比较分散。

使用block的代码比较集中统一。”



### 响应者链

当发生事件响应时，必须知道由谁来响应事件。在 iOS 中，由响应者链来对事件进行响应。

所有事件响应的类都是 UIResponder 的子类，响应者链是一个由不同对象组成的层次结构，其中的每个对象将依次获得响应事件消息的机会。当发生事件时，事件首先被发送给第一响应者，第一响应者往往是事件发生的视图，也就是用户触摸屏幕的地方。事件将沿着响应者链一直向下传递，直到被接受并做出处理。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象 ViewController（如果存在），然后是它的父视图（superview）对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图（top view）到窗口（UIWindow 对象）再到程序（UIApplication 对象）。如果整个过程都没有响应这个事件，该事件就被丢弃。一般情况下，在响应者链中只要由对象处理事件，事件就停止传递。

一个典型的事件响应路线如下：

First Responser --> The Window --> The Application --> nil（丢弃）

### RUNLOOP 具体使用场景 是否有RUNLOOP开发经验

1. NSTimer
2. 常驻线程：在子线程中开启一个runloop : RunLoop与NSURLConnection的结合


### runloop 和线程的关系：
1. 主线程的run loop默认是启动的
2. 对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要
3. 在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。

NSRunLoop *runloop = [NSRunLoop currentRunLoop];


### 1）dealloc调用时机

象的RetainCount函数=0的时候，系统会马上调用Dealloc函数释放该资




























































